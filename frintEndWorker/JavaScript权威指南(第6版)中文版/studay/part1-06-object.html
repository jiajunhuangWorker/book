<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>第六章对象</title>
		<link rel="stylesheet" href="../../../globalBase.css">
	</head>
	<body>
		<dl>
			<dt>6.对象</dt>
			<dd>对象是javascript的基本数据类型,对象是一种复合值，它将很多值聚合在一起,通过名字访问这些值</dd>
			<dd>对象也可以看做是属性的无序集合，每个属性都是键值对</dd>
			<dd>散列，散列表，字典，关联数组的基本数据类型和对象相似</dd>
			<dd>对象可以称为原型的对象继承属性,对象里面的方法通常是继承属性</dd>
			<dd>原型式继承是javascript的核心特征</dd>
			<dd>对象最常见的用法是创建，设置，查找，删除，检测和枚举它的属性</dd>
			<dd>对象中不存在同名属性</dd>
			<dd>属性的特征(可写,可枚举,可配置)</dd>
			<dd>可写:表明是否可以设置属性值</dd>
			<dd>可枚举:表明是否可以通过for/in循环返回该属性</dd>
			<dd>可配置:表明是否可以删除或修改该属性</dd>
			<dd>对象特征(对象原型，对象类，对象的扩展标记)</dd>
			<dd>对象的原型(prototype):指向另外一个对象,本对象的属性继承自它的原型对象</dd>
			<dd>对象的类(class):是一个标识对象类型的字符串</dd>
			<dd>对象的扩展标记:是否可以向该对象添加新属性</dd>			
			<dd>三类javascript对象和两类属性</dd>
			<dd>内置对象:</dd>
			<dd>是由ECMAScript规范定义的对象或类.example:数组,函数,日期和正则表达式都是内置对象</dd>
			<dd>宿主对象<dd>
			<dd>javascript解析器所嵌入的宿主环境（web浏览器定义的）客户端javascript中表示页面结构的htmlElement对象均是宿主对象</dd>
			<dd>自定义对象<dd>
			<dd>运行中的javascript代码创建的对象</dd>
			<dd>自有属性<dd>
			<dd>直接在对象中定义的属性</dd>
			<dd>继承属性<dd>
			<dd>对象的原型对象中定义的属性</dd>
								
			<dt>6.1创建对象</dt>			
			<dd>可以通过对象直接量,关键字new 和Object.create()函数来创建对象.</dd>	
			
			<dt>6.1.1对象直接量</dt>			
			<dd>对象直接量最后一个属性可以忽略逗号,但是IE会报错</dd>
			<dd>计算对象直接量的时候都会计算每个属性值</dd>	
			
			<dt>6.1.2通过new创建对象</dt>
			<dd>关键字后跟随一个函数调用,这里称为构造函数</dd>
			<dd>javascript语言核心中的原始类型都包含内置构造函数</dd>	
			
			<dt>6.1.3原型</dt>
			<dd>每一个对象都从原型继承属性</dd>
			<dd>Object.prototype获取对原型的引用</dd>
			<dd>Date对象的属性同时继承自Date.prototype和Object.prototype，这一系列链接的原型对象就叫原型链</dd>

			<dt>6.1.4Object.create()</dt>
			<dd>Object.create()是一个静态函数</dd>
			
			<dt>6.2属性的查询和设置</dt>
			<dd>当使用方括号时,我们说方括号内的表达必须返回字符串</dd>
			
			<dt>6.2.1作为关联数组的对象</dt>
			<dd>object.property和object['property']</dd>
			<dd>object['property']这个数组元素是通过字符串索引,这种数组也叫做关联数组别称散列，映射或字典,javascript对象都是关联数组的</dd>
			<dd>javascript中式弱类型语言因此对象中程序可以创建任意数量属性</dd>	
			<dd>数组写法和用字符串表达来访问对象属性的灵活性</dd>
			
			<dt>6.2.2继承</dt>
			<dd>javascript对象具有'自由属性',也有一些属性是从原型对象继承而来</dd>
			<dd>如果是同属性名的情况下老的属性名下的值会被同名新的属性值覆盖,说明属性赋值是先检查原型链是否允许赋值，如果允许属性赋值操作，它总是在原始对象上创建属性或对已有的属性赋值而不会修改原型链，只有在查询属性的时候才会到继承的存在</dd>
			
			<dt>6.2.3属性访问错误</dt>
			<dd>属性访问并不总是返回或设置一个值</dd>
			<dd>查询一个不存在的属性并不会报错，当原型链中也没查到属性的情况下返回undifined</dd>
			<dd>如果对象不存在那么试图试图查询这个不存在对象的属性会报错</dd>
			<dd>给null和undifined设置属性也会报错</dd>
			<dd>Object.prototype=o//赋值失败,但不报错要在user static严格模式下才报错</dd>	
			<dd>对象里面的属性只读，不能对只读属性赋值</dd>
			<dd>对象中的属性时继承的并且它是只读模式</dd>
			
			<dt>6.3删除属性</dt>
			<dd>delete运算符，可以删除属性</dd>
			<dd>delete是断开属性和宿主对象的联系</dd>
			<dd>delete只能删除自有属性,不能删除继承属性</dd>
			<dd>delete object.attr如果属性存在返回true</dd>
			<dd>delete 后面不是一个属性访问表达式同样返回true</dd>
			<dd>在严格模式下不能删除全局对象</dd>
			<dd>delete后跟随一个非法操作数在严格模式下会报错</dd>

			<dt>6.4检测属性</dt>
			<dd>javascript对象可以看做是属性的集合</dd>
			<dd>检测集合中成员的所属关系</dd>
			<dd>in,hasOwnPrepert和propertyIsEnumerable</dd>
			<dd>in:属性是否存在对象中</dd>
			<dd>hasOwnProperty:检测对象里面存不存在自己的属性</dd>
			<dd>propertyIsEnumerable是hasOwnPrepert的增强版,只能检测到自有属性和该属性可枚举才返回true</dd>
			<dd>!==是可以区分undifined和null</dd>

			<dt>6.5枚举属性</dt>
			<dd>遍历对象:for/in可以遍历对象中的所有课枚举的属性(自有属性和继承属性)</dd>
			<dd>对象继承的内置方法不可枚举,代码中给对象添加的属性时可枚举的</dd>
			<dd>Object.prototype添加了新的方法和属性,这些方法和属性可以被所有对象继承使用,ECMAScript5标准前这些新添加的方法是不能定义为不可枚举的，for/in需要过滤返回的属性</dd>
			<dd>Object.keys()//枚举属性名称返回array</dd>
			<dd>Object.getOwnpropertyNames()//返回对象自有属性的名称</dd>

			<dt>6.6属性getter和setter</dt>
			<dd>对象属性是由名字,值和一组特性构成的</dd>
			<dd>属性可以用getter和setter来定义,这种属性称为存取器属性</dd>
			<dd>当程序查询存取属性的值时调用getter方法,这个方法回来的方法将复制表达式右侧的值当做参数的传入setter</dd>
			<dd>setter方法是只写属性的</dd>





			<dd>对象属性是由名字，值和一组特性构成的，在ecma5中属性值可以用getter和setter方法来进行存取器属性
			<br>getter：当程序查询存取器属性的值时javascript调用getter方法 返回存储属性的值.
			<br>setter：当设置存储属性的值时.set方法主要是用来检测的时候使用到了！！！！！！！如果不合法的时候就会报错
			<br>存储属性和属性属性区分：存取器属性不具有可写性，如果属性具有getter/setter方法时那么它具有读/写属性			
			<br>笛卡尔坐标系就是直角坐标系和斜角坐标系的统称.相交于原点的两条数轴,构成了平面放射坐标
			</dd>
			<dt>8.属性的特征</dt>
			<dd>除了包括名字和值之外，属性还包括了一些标识符，可写，可枚举，可配置的特征
			<br>一个属性包含一个名字和4个特征（值（存取器属性不包含value特性），可写性，可枚举，可配置属性）（读，取，写，可枚举，可配置性）
			Ecma5定义了属性描述符，属性描述符对象的属性(value,writable,enumerable,configurable)它们都是布尔类型的存储器属性描述符(get，set替代了value和writable)set和get是函数值
			<br>Object.getOwnPropertyDescriptor()可以获得某个对象属性的属性描述符(只能获取到自有属性的描述符，如果想获取继承属性的特征需要遍历原型链)《Object.getPrototypeOf》
			<br>Object.defineProperty():设置属性的特性，或者想让新建属性具有某种特性，传入的修改对象，要创建或修改的属性的名称以及属性描述的对象
			<br>Object.defineProperties():修改或者创建多条属性（第一个参数是要修改的独享，第二个参数是要映射的表）
			</dd>
			<dt>9.对象的三个属性</dt>
			<dd>每一个对象都有和它相似的原型，类和可扩展性</dd>			
			<dt>9.1原型属性</dt>
			<dd>对象的原型属性是用来继承属性的，原型属性是在实例对象创建之初就设置好了
			Object.getPrototypeOf()可以查询它的原型,通过new表达式创建的对象会继承一个constructor属性
			<br>constructor属性:这个属性就会指代创建这个对象的构造函数
			constructor.prototype:这个构造函数时new 创建的对象的真正原型 <br>
			isPrototypeOf():检测一个对象是另一个对象的原型(或处于原型链中)；
			</dd>
			<dt>9.2类属性</dt>
			<dd>对象的类属性表示一个字符串，用以表示对象的类型信息.
			<br>classof函数：可以传入任何类型的参数
			</dd>
			<dt>9.3可扩展</dt>
			<dd>对象的可扩展性是表示是否可以给对象添加新的属性.所有的内置对象和自定义的对象都是显示可扩展的，宿主对象的可扩展是由javascript引擎定义的
			<br>Object.esExtensible()：判断对象是否可扩展
			<br>Object.preventExtensions():将可扩展的对象变成不可扩展属性
			<br>注意：一旦将对象转换为不可扩展，就无法再将其转换回克扩展，preventExtensions()只会影响对象本身，如果给一个不可扩展的对象添加属性，这个不可扩展的对象同样会继承这些新的属性
			<br>Object.seal()和Objecy.preventExtensions类似，Object.seal除了能够将对象设置为不可扩展之外还可以将对象的所有的属性都设置为不可扩展
			<br>Object.isSealed（）来检测对象是否封闭
			<br>Object.freeze（）将更严格地锁定对象
			<br>Object.isFrozen（）检测是否被冻结
			</dd>
			<dt>10.序列化对象</dt>
			<dd>对象的序列化就是将对象转换为字符串，或者将字符串转换为对象
			<br>
			JSON（JAVASCRIPT OBJECT NOTATION）
			<br>
			JSON.stringify()：只能序列化对象可枚举的自有，对于不能序列化的属性来说将会被忽略

			<br>
			JSON.parse()
			</dd>
			<dt>11.对象方法</dt>
			<dd>toString()</dd>
			<dd>toLocaleString():这个对象本地化字符串</dd>
			<dd>toJSON(),JSON.stringify调用了toSJON()方法</dd>
			<dt>11.1valueOf:</dt>
			<dd>需要将对象转换为某种原始值而非字符串的时候才用到它尤其是转换为数字的时候</dd>

		</dl>		
	</body>
	<script type="text/javascript">
	'user static';
	console.info('------------------------------6对象------------------------------')
	
	console.info('------------------------------6.1创建对象------------------------------')
	console.info('Object',Object);
	console.info('new Object()',new Object());
	console.info('Object()',Object());
	console.info(Object.create({}));
	console.info('{}',{});

	console.info('------------------------------6.1.1对象直接量------------------------------')
	var object={
		title:'javascript图书馆'
		,content:'javascript内容'
		,author:{
			name:'lucas'
			,book:'javascript权威'
		}
		,new:{
			try:'测试关键字能不能做名称'
			,String:'好像可以'
		}
	};
	console.info('object',object);

	console.info('------------------------------6.1.2通过new创建对象------------------------------')
	var date=new Date();
	var str=new String();
	var rex=new RegExp();

	console.info('------------------------------6.1.3原型------------------------------')
	console.info('Object原型:Object.prototype',Object.prototype)
	console.info('Array原型:Array.prototype',Array.prototype)
	console.info('Date原型:Date.prototype',Date.prototype)
	console.info('RegExp原型:RegExp.prototype',RegExp.prototype)
	console.log("Date instanceof Object:"+(date instanceof Object));
	console.log("string instanceof Object:"+(str instanceof Object));
	console.log("ReExp instanceof Object:"+(rex instanceof Object));
	console.info('------------------------------6.1.4Object.create()------------------------------')
	console.info('Object.create({x:1,y:2})',Object.create({x:1,y:2}));
	console.info('Object.create(null)//不继承任何原型链',Object.create(null));
	console.info('Object.create(Object.prototype)//继承原型链',Object.create(Object.prototype))
	// console.log("JSON.stringify(obj1):"+JSON.stringify(obj1));
	function inherit(obj){
		if(obj==null)throw TypeError();
		if(Object.create){
			return Object.create(obj);
			var t=typeof obj;
			if(t!=='object'&& t!=='function'){
				function f(){
					f.prototype=obj;
					return new f();
				}
			}
		}
	}
	var object={x:111,y:22};
	console.info('inherit(object)',inherit(object))

	console.info('------------------------------6.2属性的查询和设置------------------------------')

	console.info('------------------------------6.2.1作为关联数组的对象------------------------------')
	var addr='',customer={};
	for(var i=0;i<4;i++){
		addr+=customer['address'+i]+'\n';
	}
	console.info('addr:',addr,'customer',customer);

	function getValue(portfolio){
		var total=0.0;
		for(stock in portfolio){
			var shares=portfolio[stock];
			var price=getquote(shares);
			total+=shares*price;
		}
		return total;
	}
	console.info('------------------------------6.2.2继承------------------------------')
	var o={};
		o.x=1;
	var p=inherit(o);
		p.y=2;
	var q=inherit(p);
		q.z=3;
	var s=q.toString();
	console.info('q.x+q.y:',q.x+q.y);
	// demo2
	var unitcircle={r:1};
	var demo2=inherit(unitcircle);
		demo2.x=1;demo2.y=2;
		demo2.r=666;
		console.info('demo2:',demo2,'unitcircle://原型链没发生改变',unitcircle);

	console.info('------------------------------6.2.3属性访问错误------------------------------')
	var len=undefined;
	var book=null;
		if(book){
			if(book.subtitle) len=book.subtitle.length;
		}


		// 第二种防止报错
		var lens=book && book.subtitle && book.subtitle.length;

	console.info('------------------------------6.3删除属性------------------------------')
	var a={p:{x:1}};
	var b=a.p;
		delete a.p;
		console.info('b.x',b.x);
		console.info('javascript 的某些实现中,可能因为这种不严格严谨的代码而造成内存泄露因此需要先进行遍历属性在进行依次删除');

	var object_deleteAttr={x:1};
		console.info('delete object_deleteAttr.x',delete object_deleteAttr.x)
		console.info('delete object_deleteAttr.x',delete object_deleteAttr.x)
		console.info('object_deleteAttr.toString()',object_deleteAttr.toString());

		console.info('delete Object.prototype',delete Object.prototype)

	console.info('------------------------------6.4检测属性------------------------------')
	var val={x:1,y:2};
	console.log("{x:1,y:2}");
	console.log("val.hasOwnPreperty('x'):"+val.hasOwnProperty('x'));
	console.log("val.hasOwnPreperty('z'):"+val.hasOwnProperty('z'));
	console.log('val.hasOwnProperty("toString"):'+val.hasOwnProperty('toString'));//证明了不能检测父级原型
	console.log("val.propertyIsEnumerable('x'):"+val.propertyIsEnumerable('x'));
	console.log("val.propertyIsEnumerable('z'):"+val.propertyIsEnumerable('z'));
	console.log('val.propertyIsEnumerable("toString"):'+val.propertyIsEnumerable('toString'));
	console.log('Object.prototype:'+Object.prototype);

	console.log('val.x!==undefined',val.x!==undefined);

	console.info('------------------------------6.5枚举属性------------------------------')
	var for_inObj={x:1,y:2,c:3};
	for_inObj.propertyIsEnumerable('toString');//返回false 不能枚举
	for(p in for_inObj){
		console.info('p',p)
	}

	//过滤器
	var filtration=function (){
		for(p in for_inObj){
			if(!for_inObj.hasOwnProperty(p)) continue;//跳过继承的属性
		}
		for(p in for_inObj){
			if(typeof for_inObj[p] === 'function') continue;//跳过方法
		}
	}
	console.info('过滤属性和方法',filtration);

	var extend=function extend(o,p){
		/*
			工具函数来操控对象的属性extend()函数
			把P中的可美剧属性赋值到o中并返回o
			如果o和p中含有同名属性则覆盖o中的属性
			这个函数并不处理getter和setter以及复制属性
		*/
		//弥补了IE中一些bug
		for(prop in p){
			o[prop]=p[prop];
		}
		return o;
	}
	console.info('将p中的所有属性都整合到o中\n',extend);
	var extend2=function extend(o,p){
		/*
			工具函数来操控对象的属性extend()函数
			把P中的可美剧属性赋值到o中并返回o
			如果o和p中含有同名属性则覆盖o中的属性
			这个函数并不处理getter和setter以及复制属性
		*/
		//弥补了IE中一些bug
		for(prop in p){
			if(o.hasOwnProperty[prop]) continue; 
			o[prop]=p[prop];
		}
		return o;
	}
	console.info('过滤掉已经存在o中存在的属性\n',extend2);

	var deleteData=function restrict(o,p){
		/*
			工具函数来操控对象的属性extend()函数
			把P中的可美剧属性赋值到o中并返回o
			如果o和p中含有同名属性则覆盖o中的属性
			这个函数并不处理getter和setter以及复制属性
		*/
		for(prop in p){
			if(!(prop in o)) delete o[prop];
		}
		return o;
	}
	console.info('过滤掉p中存在的属性\n',deleteData);

	var key=function key(o){
		/*
			返回一个数组,数组包含的是o中可美剧的自有属性的名字
		*/
		if(typeof o!=='object') throw TypeError();
		var result=[];
		for(var prop in o){
			if(o.hasOwnProperty(prop)){//判断是否自有属性
				result.push(prop)
			}
			return result;
		}
	}
	console.info('数组包含的是o中可美剧的自有属性的名字\n',key);
	// console.log('6.枚举属性----------------extend');
	// function extend(o,p){
	// 	for(prop in p){
	// 		o[prop]=p[prop];
	// 	}
	// 	return o;
	// }
	// console.log('6.枚举属性----------------keys');
	// function keys(o){
	// 	if(typeof o !=='object') throw TypeError();
	// 	var result=[];
	// 	for(var prop in o){
	// 		if(o.hasOwnProperty(prop))
	// 			result.push(prop);
	// 	}
	// 	return result;
	// }
	// console.log('7.属性getter和setter----------------');
	// var p={
	// 	x:0,
	// 	y:0,
	// 	get r(){						
	// 		return this.x+this.y;
	// 	},
	// 	set r(n){			
	// 		debugger;			
	// 		if(this.x<5){
	// 			throw new Error("x不能少于5");
	// 		}
	// 	},
	// 	get thera(){
	// 		//atan2是表示x轴到点x，y之间的角度
	// 		return Math.atan2(this.y,this.x);
	// 	}
	// }
	// var q=inherit(p);	
	// q.x=2,q.y=3;
	// console.log("get:q.r:"+q.r);	
	// console.log("q.thera:"+q.thera);
	// console.log('7.1设置当前的序列号-----------------------');
	// var serialnum={
	// 	//$符号暗示这回属性是一个私有的属性
	// 	$n:6,
	// 	get next(){
	// 		return ++this.$n;
	// 	},
	// 	set next(n){				
	// 		if(n>=this.$n){				
	// 			this.$n=n;				
	// 		}else{
	// 			throw new Error("传入的值不够大："+n+"至少传入6");
	// 		}
	// 	}
	// }
	// var s=inherit(serialnum);
	// console.log("set:s.next:"+(s.next=10)+"<br/>");
	// console.log(s.next);
	// console.log('7.2随机对象-----------------------');
	// var radom={
	// 	get octet(){return Math.floor(Math.random()*256);},
	// 	get octet2(){return Math.floor(Math.random()*65536);},
	// 	get octet3(){return Math.floor(Math.random()*65536)-32768;}
	// }
	// console.log(radom.octet);
	// console.log(radom.octet2);
	// console.log(radom.octet3);
	// console.log("");
	// console.log('8.Object.getOwnPropertyDescriptor()-----------------------');
	// console.log("Object.getOwnPropertyDescriptor({x:1,y:2},'y'):"+(Object.getOwnPropertyDescriptor({x:1,y:2},"y")));
	// console.log("Object.getOwnPropertyDescriptor({},'x'):"+Object.getOwnPropertyDescriptor({},"x"));//没有这个属性
	// console.log("Object.getOwnPropertyDescriptor({},'toString'):"+Object.getOwnPropertyDescriptor({},"toString"));//继承属性
	// console.log('8.1 Object.defineProperty（）-----------------------');
	// var o={};
	// Object.defineProperty(o,"x",{value:'666',writable:true,enumerable:false,configurable:true});
	// console.log("o.x:"+o.x);
	// console.log("Object.keys(o):"+Object.keys(o));//不可枚举
	// Object.defineProperty(o,"x",{writable:false});
	// o.x=888;
	// console.log("o.x:"+o.x);//不能够修改属性值
	// Object.defineProperty(o,"x",{value:"999"});
	// console.log("o.x:"+o.x);//修改属性值
	// //将数据属性修改为存储属性
	// Object.defineProperty(o,"x",{get:function(){
	// 	return o;
	// }})
	// 	console.log('8.2  Object.defineProperties()-----------------------');
	// 	var p =Object.defineProperties({},{
	// 		x:{value:'666',writable:true,enumerable:false,configurable:true},
	// 		y:{value:'777',writable:true,enumerable:false,configurable:true},
	// 		r:{
	// 			get:function(){
	// 				return 666
	// 			},enumerable:false,configurable:true
	// 		},
	// 	})
	// 	console.log("p.x:"+p.x);
	// 	console.log("p.y:"+p.y);
	// 	console.log("");
	// 	console.log('9.1isPrototypeOf()-----------------------');
	// 	var s={x:1};//定义一个原型对象
	// 	var p=Object.create(s);//使用这个原型创建一个对象
	// 	console.log("s.isPrototypeOf(p):"+s.isPrototypeOf(p));//p继承自s
	// 	console.log("Object.prototype.isPrototypeOf(p):"+Object.prototype.isPrototypeOf(p));//p自称自Object.peototype
	// 	console.log('10.序列化-----------------------');
	// 	var o={a:1,b:{c:[false,'true']}};
	// 	var s=JSON.stringify(o);
	// 	console.log("JSON.stringify(o):"+JSON.stringify(o));//对象转字符串
	// 	console.log("typeof JSON.stringify(o):"+typeof JSON.stringify(o));
	// 	console.log("JSON.stringify(o):"+JSON.parse(s));//字符串转对象
	// 	console.log("typeof JSON.stringify(o):"+typeof JSON.parse(s));

	</script>
</html>