<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>13.6安全性</title>
		<link rel="stylesheet" href="../../../globalBase.css">
	</head>
	<body>
		<dl>
			<dt>13.6安全性</dt>
			<dd>web浏览器中包含javascript解析器,也就是说一旦载入web页面,就可以让任意的javascript代码在计算机里执行.很明
			显,这里存在着安全隐患,浏览器厂商也不断地权衡下面这两个方面之间博弈</dd>
			<dd>定义强大的客户端API,启用强大的web应用</dd>
			<dd>阻止恶意代码读取或修改数据,盗取隐私,诈骗或浪费时间</dd>

			<dt>13.6.1javascript不能做什么</dt>
			<dd>web浏览器针对恶意代码的第一条防线就是它们不支持某些功能(客戶端JavaScript沒有权限写入或删除客户计计算机上的任意文件或列出任意目录.javascript程序不能删除数据或植入病毒)</dd>
			<dd>客户端javascript没有任何通用的网络能力,客戶端javascript程序可以对HTTP协议编程,并且html5有一个附属标准叫webSockets,定义了一个类套接字的api,用于和指定的服务器通信.这些api都不允许对于范围更广的网络进行直接访问,通用的Internet客户端和服务器不能同时使用客户端javascript来写</dd>
			<dd>第二条防线是在自己支持的某些功能上施加限制</dd>
			<dd>1.javascript程序可以打开一个新的浏览器窗口,但是为了防止广告商滥用弹出窗口,很多浏览器限制了这一功能,使得只有为了响应鼠标点击这一的用户触发事件的时候,才能使用它</dd>
			<dd>2.javascript程序可以关闭自己打开的浏览器窗口,但是不允许它不经过用户确认就关闭其他的窗口</dd>
			<dd>3.HTML fileUpload元素的value属性是只读的,如果可以设置这个属性,脚本就能设置它为任意的期望的文件名,从而导致表单上传指定文件的内容到服务器</dd>
			<dd>4.脚本不能读取从不同服务器载入的文档的内容,除非这个就是包含该脚本的文档.类似地,一个脚本不能在来自不同服务器的文档上注册事件监听器,这就防止脚本窃取其他页面的用户输入.这一限制叫同源策略</dd>
			<dd>这里并未给出所有的客户端javascript的限制项,不同浏览器有不同的安全策略,并可能实现不同的api限制.部分浏览器可能还允许根据用户偏好来增强或减弱限制</dd>
			<dd>严格讲服务器 来自于不同的域,端口或协议</dd>

			<dt>13.6.2同源策略</dt>
			<dd>同源策略是对javascript代码能够操作哪些web内容的一条完整的安全限制.当web页面使用多个iframe元素或者打开其他浏览器窗口的时候,这一策略通常就会发挥作用.同源策略负责管理窗口或窗体中javascript代码以及和其他窗口或帧的交互</dd>
			<dd>脚本只能读取和所属文档来源相同的窗口和文档属性</dd>
			<dd>文档的来源包含协议,主机,以及载入文档的url端口.从不同web服务器载入的文档具有不同的来源.同一主机不同端口载入的文档具有不同的来源,使用http协议载入的文档和使用https协议载入的文档具有不同的来源,即使它们来自同一个服务器</dd>
			<dd>脚本本身的来源和同源策略并不相关,相关的是脚本所嵌入的文档的来源(假设一个来自主机A的脚本被包含到宿主B的一个web页面中,这个脚本的来源是主机B,并且完整地访问包含它的文档的内容.如果脚本打开一个新窗口并载入来自主机B的另一个文档,脚本对这个文档的内容也具有完全的访问权限.但是如果脚本打開第三個窗口并载入一个来自主机C的文档,同源策略就会发挥作用住址脚本访问这个文档)</dd>
			<dd>同源策略并非应用于不同源的窗口中的所有对象的所有属性.不过它应用到了其中的大多数属性,尤其是对document对象几乎所有属性而言.凡是包含另一个服务器中文档的窗口或窗体,都是同源策略的范围</dd>
			<dd>同源策略还应用于使用XMLHTTPRequest生成的HTTP请求.这个对象允许客户端javascript生成任意的HTTP请求到脚本所属文档的web服务器,但是不允许脚本和其他web服务器通信</dd>
			<dd>對於防止脚本竊取似有的信息來說,同源策略是必须的(恶意脚本就能够读取窗口的内容并将其发送回自己的服务器.同源策略防止了这种行为)</dd>

			<dd>不嚴格的同源策略,三種不严格的同源策略</dd>
			<dd>1.同源策略给那些使用多个子域的大站点带来了一些问题,为了支持这种类型的多域名占点.可以使用document对象的domain属性,默认情况下,属性domain存放的是载入文档的服务器的主机名.可以设置这一属性,不过使用的字符串必须具有有效的域前缀或它本身.如果domain属性的初始值是字符串就可以设置,domain值中必须有一个点号,不能把它设置为com或其他顶级域名</dd>
			<dd>1、如果两个窗口(或窗体)包含的脚本把domain设置成了相同的值,那么这两个窗口就不再手同源策略的约束,它们可以互相读取对方的属性.脚本可以把他们的document.domain属性都设置为相同的服务器,这样一来,这些文档就有了同源性,可以互相读取属性</dd>
			<dd>2、跨域资源共享.这个标准草案用新的Origin请求头和新的Access-Control-Allow-Origin响应头来扩展HTTP.它允许服务器用头信息显式地列出源,或使用统配符来匹配所有的源并允许由任何地址请求文件,使用新的头信息来允许跨域HTTP请求,这样XMLHttpRequest就不会被同源策略限制了</dd>
			<dd>3、跨文档消息,允许来自一个文档的脚本可以传递文本消息到另一个文档的脚本,而不管脚本的来源是否不同.window对象上的postMessage()方法可以异步传递消息事件onmessage事件句处理程序函数来处理它到窗口的文档里.一个文档里的脚本还是不能调用在其他文档里的方法和读取属性,但他们可以用这种消息传递技术来实现安全的通信</dd>

			<dt>13.6.3校本化插件和ActiveX控件</dt>
			<dd>尽管核心javascript语言和基本的客户端对象模型缺乏大多数恶意代码所需要的文件系统功能和网络功能但情况并不像看上去name简单</dd>
			<dd>校本化AceiveX控件和插件的功能存在着安全的问题,javas applet具有访问底层网络的能力.java安全沙箱阻止applet和载入它的服务器之外的任何服务器进行通信,因此这并未打开一个安全漏洞,如果插件是可以脚本化的.我们不仅要无条件相信web浏览器的安全架构,还要相信插件的安全架构,操作系统还存在很多可被控件利用的安全漏洞</dd>

			<dt>13.6.4跨站脚本</dt>
			<dd>跨站脚本或者叫xss,这个术语用来标识一类安全问题,也就是攻击者向目标web站点注入html标签或者脚本.客户端javascript程序员也必须意识到或者能够预防跨站脚本.</dd>
			<dd>web页面动态地产生文档内容,并且这些文档内容基于用户提交的数据的,而并没有通过从中移除任何嵌入的html标签来消毒的话,nameweb很容易遭到扩展脚本攻击</dd>
			<dd>跨站脚本攻击就是因为它涉及多个站点,站点B或C包含一个专门构造的到站点A的链接,它会注入一个来自站点B的脚本,恶意脚本可以读取站点A所存储的cookie然后把数据传送回站点B</dd>
			<dd>防止XSS攻击的方式是,在使用任何不可信的数据来动态创建文档内容之前从中移除html标签</dd>
			<dd>将字符串中任意html标签进行转移和过滤删除处理.ie8定义了一个更加微妙的toStaticHtml()方法,可以移除script标签而不修改不可执行的html.toStaticHtml()是不标准的,但在javascript核心代码中实现一个html安全函数也非常简单</dd>
			<dd>html5的内容安全策略则更进一步,它为iframe元素定义了一个sandbox属性，它允许显示不可信的内容,自动禁用脚本</dd>
			<dd>	跨站脚本使得一个有害的漏洞能够立足于web的架构之中</dd>

			<dt>13.6.5拒绝服务攻击</dt>
			<dd>同源恶略和其他的安全限制可以很好地预防恶意代码销坏数据或放置千帆隐私这种问题。拒绝服务供给这种供给手法非常暴力,某些浏览器可以检测运行时间很长的脚本,并且让用户终止它们</dd>
		</dl>
	</body>
</html>
<script type="text/javascript">
	'user static';
	console.info('------------------------------13.6.4跨站脚本------------------------------');
	var name=decodeURIComponent(window.location.search.substring(1))||'';
	document.write('hellow'+name);
	console.info('XSS预防')
	name=name.replace(/</g,"&lt;").replace(/>/g,"&gt;");
</script>