<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>8.2函數调用</title>
		<link rel="stylesheet" href="../../../globalBase.css">
	</head>
	<body>
		<dl>
			<dt>8.2函数调用</dt>
			<dd>构成函数主体的javascript代码在定义之时并不会执行,只有调用函数时,它们才会执行</dd>
			<dd>4种方式调用JavaScript函数</dd>
			<dd>作为函数</dd>
			<dd>作为方法</dd>
			<dd>作为构造函数</dd>
			<dd>通过他们的call()和apply方法</dd>
			<dd>有些JavaScript的实现并未严格遵守这条规则,比如,FireFox就允许在if语句中出现条件函数声明</dd>

			<dt>8.2.1函数调用</dt>
			<dd>使用调用表达式可以进行普通的函数调用也可以进行方法调用,一个调用表达式由多个函数表达式组成,每个函数表达式都是由一个函数对象和左圆括号,参数列表和右圆括号组成,参数列表是由逗号分隔的零个或多个参数表达式组成</dd>

			<dt>8.2.2方法调用</dt>
			<dd>一个方法无非是个保存在一个对象的属性里的javascript函数</dd>
			<dd>方法调用和函数调用区别,方法调用可以调用上下文,属性访问表达式由两部分组成,一个是对象和属性,可以通过关键字this去引用对象</dd>
			<dd>方法和this关键字是面向对象编程范例的核心,任何函数只要作为方法调用实际上都会传入一个隐式的实参,这个实参是一个对象,方法调用的母体就是这个对象</dd>
			<dd>方法链</dd>
			<dd>当方法返回值是一个对象,这个对象还可以调用它的方法,这种方法调用序列中(通常称为'链'或者'级联'),每次的调用结果都是另外一个表达式的组成部分.</dd>
			<dd>当方法并不需要返回值时最好返回this,如果设计api中一直采用这种方式(每个方法都返回this),使用api就可以进行'链式调用'风格进行编程</dd>
			<dd>javascript不允许给this赋值,关键字this没有作用域的限制,嵌套的函数不会从调用它的函数中继承this,</dd>

			<dt>8.2.3构造函数调用</dt>
			<dd>构造函数调用创建一个新的空对象,这个对象继承自构造函数prototype属性,构造函数试图初始化这个心创建的对象，构造函数通常不适用return关键字，它们通常初始化新对象,构造函数调用return语句返回一个对象
			</dd>

			<dt>8.2.4间接调用</dt>
			<dd>call()和apply()可以间接调用函数,两个方法都允许显式指定调用所需的this值</dd>
			<dd>call()方法使用它自有的实参列表作为函数的实参</dd>
			<dd>apply()方法则要求以数组的形式传入参数</dd>
		</dl>
	</body>
	<script type="text/javascript">
	'user static';
	console.info('------------------------------8.2.1函数调用------------------------------');
	function printprops(o){
		for(var p in o)
			console.info(p+":")
	}
	var static=(function(){return this}());
	console.info(static,'//定义并调用一个函数来确定当前运行脚本运行时是否使用严格模式')

	console.info('------------------------------8.2.2方法调用------------------------------');
	var calculator={
		operand:1,
		operand1:1,
		add:function(){
			this.result=this.operand+this.operand1;
		}
	}
	console.info('对象',calculator,'\n调用calculator.add()方法:',calculator.add(),'result结果:',calculator.result);
	var object={
		m:function(){
			var self=this;
			console.info(this===object);
			f();
			function f(){
				console.info(this===obejct);
				console.info(self===object);
			}ss
		}
	}
	console.info(object);
	console.info('------------------------------8.2.3构造函数调用------------------------------');
	console.info('------------------------------8.2.4间接调用------------------------------');
	</script>
</html>
