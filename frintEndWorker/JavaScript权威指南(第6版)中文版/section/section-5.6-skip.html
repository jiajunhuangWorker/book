<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>5.6跳转</title>
		<link rel="stylesheet" href="../../../globalBase.css">
	</head>
	<body>
		<dl>
			<dt>5.6跳转</dt>
			<dd>跳转语句使得javascript执行可以从一个位置跳转到另一个位置</dd>
			<dd>break(跳转到循环或者其他语句的结束)</dd>			
			<dd>continue(终止本次循环的执行下次循环)</dd>
			<dd>return(语句让解析器跳出函数体的执行，并返回结果)</dd>
			<dd>throw(抛出异常  try/catch/finally)</dd>

			<dt>5.6.1标签语句</dt>
			<dd>语句是可以添加标签的,标签是由语句前的标识符和冒号组成</dd>
			<dd>identifer:statement</dd>
			<dd>通过给语句定义标签,就可以在程序的任何地方通过标签名引用这条语句</dd>
			<dd>标签的命名空间和变量或函数的命名空间是不同的,因此可以使用同一个标识符作为语句标签和作为变量名或函数名</dd>
			<dd>一个语句标签不能和它内部的语句标签重名，但在两个代码段不相互嵌套的情况下是可以出现同名的语句标签的</dd>
			
			<dt>5.6.2break</dt>
			<dd>单独使用break语句的作用是立即退出最内层的循环或switch语句</dd>
			<dd>当break和标签一块使用时,程序将跳转到这个标签所标识的语句块结束,或者直接终止这个闭合语句块的执行</dd>
			<dd>当没有任何闭合语句块指定了break所用的标签,这时会产生一个语法错误</dd>
			<dd>break关键字和labelname之间不能换行.因为Javascript可以给语句自动补全省略掉的分号,如果break关键字和标签之间有换行,javascript解析器会认为你在使用break不带标签的最简形式,因此会再break后补充分号</dd>
			<dd>不管break语句带不带标签,它的控制权都无法越过函数的边界</dd>

			<dt>5.6.3continue</dt>
			<dd>continue语句和break语句非常类似,但它不是退出循环,而是转而执行下一次循环</dd>
			<dd>不管continue语句带不带标签,它只能在循环体内使用,在其他地方使用将会报语法错误</dd>
			<dd>在while循环中,在循环开始处指定的expression会重复检测,如果检测结果为true,循环体会从头开始执行</dd>
			<dd>在do/while循环中,程序的执行直接跳到循环结尾处,这时会重新判断循环条件,之后才会继续下一次循环</dd>
			<dd>在for循环中,首先计算自增表达式,然后再次检测test表达式,用以判断是否执行循环体</dd>
			<dd>在for/in循环中,循环开始遍历下一个属性名,这个属性名赋值给了指定的变量</dd>
			
			<dt>5.6.4return</dt>
			<dd>函数调用时一种表达式,而所有表达式都有值.函数中的return语句即是指定函数调用后的返回值.</dd>
			<dd>return 返回一个结果，只能出现在函数体内出现,如果不是的话会报语法错误</dd>
			<dd>return语句可以单独用而不必带expression,这样的话函数也会向调用程序返回undefined</dd>
			
			<dt>5.6.5throw语句</dt>
			<dd>所谓异常时当发生了某种异常情况或错误时产生一个信号</dd>
			<dd>抛出异常,就是用信号通知发生了错误或者异常状况.当产生运行时错误或者程序使用throw语句时就会显式地抛出异常。</dd>
			<dd>使用try/catch/finally语句捕获异常</dd>
			<dd>throw expression(expression可以是任意类型的)</dd>
			<dd>抛出一个代表错误吗码的数字,或者包含可读的错误消息的字符串.当javascript解析器抛出异常的时候通常采用error类型和其子类型,当然也可以使用它们</dd>
			<dd>一个error对象有一个name属性表示错误类型,一个message属性用来存放传递给构造函数的字符串</dd>
			<dd>当抛出异常时,javascript解析器会立即停止当前正在执行的逻辑,并跳转至就近的异常处理程序</dd>
			<dd>如果抛出异常的代码块没有一条相关联的catch从句,解析器会检查更高层的闭合代码块,看它是否有相关联的异常处理程序。以此类推,直到找到一个异常处理程序位置</dd>
			<dd>如果抛出异常的函数没有处理它的try/catch/finally语句,异常将向上传播到调用该函数的代码,异常就会沿着javascript方法的词法结构和调用栈向上传播。</dd>
			<dd>如果没有找到任何异常处理程序,javascript将把异常当成程序错误来处理,并显示到控制台</dd>

			<dt>5.6.6try/catch/finally语句</dt>
			<dd>try/catch/finally语句是javascript的异常处理机制，try从句定义了需要处理的异常代码块,catch从句跟随在try之后,当try块内某处发生异常时，调用catch内的代码逻辑,catch从句后跟随finally块,后者中放置清理代码，不管try块中是否产生异常,finally块内逻辑总会执行</dd>
			<dd>关键字catch后跟随了一对圆括号,圆括号内是一个标识符</dd>
			<dd>当捕获一个异常时,把和这个异常相关的值赋值给这个参数.和普通的变量不同,这条catch子句中的标识符具有块级作用域,它只在catch语句块内定义</dd>
			<dd>不管try语句块中的代码执行完成多少,只要try语句中有一部分代码执行了,finally从句就会执行</dd>
			<dd>由于return,continue,break语句使得解析器跳出try语句块时,解析器在执行新的目标代码之前执行finally块中的逻辑</dd>
			<dd>如果try出现异常就会先执行catch在执行finally</dd>
		</dl>		
	</body>
	<script type="text/javascript">
		console.log('------------------------------5.6.1标签语句------------------------------');
		function myWay(n){
			loop:for(;n>0;n--){

				if(n>4){
					console.info('n>4,看看当n大于4的时候不会执行n>0 code',n);
					continue loop;
				}	
				if(n>0){
					console.info('n>0',n);
						n--;
				}			
			}
		}
		console.info('myWay(6)',myWay(6));
	
		console.log('------------------------------5.6.2break语句------------------------------');
		var sum=0,success=false,val=[10,'我是中文',20,30],row=new Array();
		com:if(val){
			for(var i=0;i<val.length;i++){
				row.push(val[i]);
				console.log('row:',row);
				if(!row) break com;
				for(var y=0;y<row.length;y++){
					var cell=row[y];
					console.log('cell:'+cell);
					if(isFinite(cell)) break com;
					sum+=cell;
					console.log("sum:"+sum);
				}
			}
		}
	
		console.log('------------------------------5.6.5throw语句------------------------------');
		function errors(x){
			if(x<0) throw new Error('x不能为负数');
			console.log("x:"+x);
		}
		console.info('errors(5)//假设入参是-5就会在console 抛出错误',errors(5));
	
		console.log('------------------------------5.6.6 try/catch/finally语句------------------------------');
		try{
			//通常来讲,这里的代码会从头执行到尾而不会产生任何问题,
			//担有时会抛出一个异常,要么是由throw语句直接抛出异常
			//要么是通过调用一个方法间接抛出异常
		}catch(e){
			//当且仅当try语句抛出了异常,才会执行这里的代码
			//这里可以通过局部变量e来获取对error对象或者抛出的其他值得引用
			//这里的代码块可以基于某种原因处理这个异常,也可以忽略这个异常
			//这可以通过throw语句重新抛出异常
		}finally{
			//不管try语句是否抛出异常,这里的逻辑总会执行,终止try语句块的方式有
			//1）正常终止,执行完语句块的最后一条语句
			//2)通过break,continue或return语句终止
			//3)抛出一个异常,异常被catch从句捕获
			//4)抛出一个异常,异常未被捕获,继续向上传播
		}
		function trys(n){
			try{
				loop:while(n>0){
					n--;
					if(n>0){						
					}else{
						console.log("不符合:"+n);
						break loop;	
					}
				}
			}catch(e){
				console.log("error:"+e);
			}finally{
				console.log("finally被执行了");
			}
		}
		console.info('trys(1)',trys(1));	
	
		
	</script>
</html>