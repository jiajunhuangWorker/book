<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<title>5.6跳转</title>
		<link rel="stylesheet" href="../../../globalBase.css">
	</head>
	<body>
		<dl>
			<dt>5.6跳转</dt>
			<dd>跳转语句使得javascript执行可以从一个位置跳转到另一个位置</dd>
			<dd>break(跳转到循环或者其他语句的结束)</dd>			
			<dd>continue(终止本次循环的执行下次循环)</dd>
			<dd>return(语句让解析器跳出函数体的执行，并返回结果)</dd>
			<dd>throw(抛出异常  try/catch/finally)</dd>

			<dt>5.6.1标签语句</dt>
			<dd>语句是可以添加标签的,标签是由语句前的标识符和冒号组成</dd>
			<dd>identifer:statement</dd>
			<dd>通过给语句定义标签,就可以在程序的任何地方通过标签名引用这条语句</dd>
			<dd>标签的命名空间和变量或函数的命名空间是不同的,因此可以使用同一个标识符作为语句标签和作为变量名或函数名</dd>
			<dd>一个语句标签不能和它内部的语句标签重名，但在两个代码段不相互嵌套的情况下是可以出现同名的语句标签的</dd>
			
			<dt>5.6.2break</dt>
			<dd>单独使用break语句的作用是立即退出最内层的循环或switch语句</dd>
			<dd>当break和标签一块使用时,程序将跳转到这个标签所标识的语句块结束,或者直接终止这个闭合语句块的执行</dd>
			<dd>当没有任何闭合语句块指定了break所用的标签,这时会产生一个语法错误</dd>


			<dt>6.3continue</dt>
			<dd>continue在for或者while循环中如果在循环体里面进行判断当遇到错误的时候就跳过循环</dd>
			
			<dt>5.6.4return</dt>
			<dd>return 返回一个结果，只能出现在函数体</dd>
			
			<dt>5.6.5throw语句</dt>
			<dd>抛出错误信息,捕获异常是指处理这个信号，采用必要的手段进行恢复 try/catch/finally语句捕获异常</dd>
			
			<dt>5.6.6try/catch/finally语句</dt>
			<dd>try/catch/finally语句是javascript的异常处理机制，try从句定义了需要处理的异常代码块,catch从句是在try后当try出现异常时调用catch内的代码逻辑,finally块后者放置清理代码，finally块必须会执行的</dd>
			
			<dt>5.7其他语句</dt>
			<dd>with,debugger,use strict</dd>
			
			<dt>5.7.1 with</dt>
				<dd>作用链:一个按序检索的对象列表，通过它可以进行变量名解析</dd>
				<dd>with语句用于临时扩展作用域，在严格模式下禁止使用witch</dd>
				<dd>缺点：with 语句不好优化，with性能低</dd>					
			<form>
				<input type="text" name="name" placeholder="try with">
			</form>
				
			<dt>5.7.2 debugger</dt>
			<dd>debugger通常什么也不做，当调试程序可以运行时,javascript解析器将会以调试模式运行，这种语句产生断点,</dd>
			
			<dt>5.7.3 use strict</dt>
			<dd>use strict 是ecmaScript5引入的一条指令。</dd>
			<dd>指令和普通的语句之间两个重要区别</dd>
			<dd>它不包含任何语言的关键字，它是一个特殊字符串直接量的表达式可以使用单引号或者双引号，它代表着脚本的开始或者函数的开始</dd>
			<dd>javascript具体的实现可能将它们解析为解析器器自有的指令，如果遵循了ecmaScript的‘use strict’后面的代码将会严格代码</dd>
			<dd>它修正了语言的重要缺陷,提供健壮的查错功能和增强了安全机制</dd>
			<dd>严格模式和非严格模式区别</dd>
			<dd>1.严格模式禁用with语句</dd>
			<dd>2.所有的变量都要先声明</dd>
			<dd>3.在严格模式中调用的函数(不是方法)中的一个this值是undefined，在严格模式中函数中的this值是指全局对象,</dd>
			<dd>4.严格模式中call()和apply()来调用函数时,其中this值就是通过call()或apply()传入第一个参数(非严格情况下null和undefined值被全局对象和转换为对象的非对象值所替换)</dd>
			<dd>5.严格:给只读属性赋值和给不可扩展的对象创建新成员将抛出一个类型错误,在非严格模式中这些操作就只会简单的操作失败不报错</dd>
			<dd>6.严格:传入eval()的代码不能在调用程序所在的上下文中声明变量或定义函数而在非严格可以这样做。相反，变量和函数定义的eval()创建新作用域中,这个eval()返回时就弃用了.</dd>
			<dd>7.严格:arguments对象拥有传入函数值静态副本.非严格模式中，arguments对象有魔术般的行为，arguments里的数组元素和函数参数都是指同一个值得引用</dd>
			<dd>8.严格模式：delete运算符跟随非法的标识符就报错，而非严格就报false</dd>
			<dd>9.严格:试图删除一个不可配置的属性将抛出一个类型错误异常在非严格模式中会抛出false</dd>
			<dd>10.一个对象定义两个或多个同名的属性将报错，而非严格模式不会</dd>
			<dd>11.在严格模式中是不允许使用八进制整数直接量非严格可以</dd>
			<dd>12.严格:eval和arguments当做关键字,他们的值不能修改不能给标识符赋值，也不能给他们声明变量，用做函数名，用做函数参数或者用做catch块的标识符</dd>
			<dd>13.严格模式中失去了调用栈的检查能力在严格模式函数中，caller，arguments，arguments.caller会抛出一个类型错误异常.当访问两个属性时将抛出类型错误异常</dd>
			</dd>
			<dt>5.8 javascript 语句小结</dt>
		</dl>		
	</body>
	<script type="text/javascript">
		console.log('------------------------------5.6.1标签语句------------------------------');
		function myWay(n){
			loop:for(;n>0;n--){

				if(n>4){
					console.info('n>4,看看当n大于4的时候不会执行n>0 code',n);
					continue loop;
				}	
				if(n>0){
					console.info('n>0',n);
						n--;
				}			
			}
		}
		console.info('myWay(6)',myWay(6));
	
		console.log('------------------------------5.6.2break语句------------------------------');
		var sum=0,success=false,val=[10,'我是中文',20,30],row=new Array();
		com:if(val){
			for(var i=0;i<val.length;i++){
				row.push(val[i]);
				console.log('row:',row);
				if(!row) break com;
				for(var y=0;y<row.length;y++){
					var cell=row[y];
					console.log('cell:'+cell);
					if(isFinite(cell)) break com;
					sum+=cell;
					console.log("sum:"+sum);
				}
			}
		}
	
		console.log('------------------------------5.6.3continue语句------------------------------');
	
		console.log('------------------------------5.6.4return语句------------------------------');
	
		console.log('------------------------------5.6.5throw语句------------------------------');
		function errors(x){
			if(x<0) throw new Error('x不能为负数');
			console.log("x:"+x);
		}
		console.info('errors(5)//假设入参是-5就会在console 抛出错误',errors(5));
	
		console.log('------------------------------5.6.6 try/catch/finally语句------------------------------');
		function trys(n){
			try{
				loop:while(n>0){
					n--;
					if(n>0){						
					}else{
						console.log("不符合:"+n);
						break loop;	
					}
				}
			}catch(e){
				console.log("error:"+e);
			}finally{
				console.log("finally被执行了");
			}
		}
		console.info('trys(1)',trys(1));	
	
		
	</script>
</html>